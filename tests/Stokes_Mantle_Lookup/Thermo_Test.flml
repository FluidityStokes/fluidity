<?xml version='1.0' encoding='utf-8'?>
<fluidity_options>
  <simulation_name>
    <string_value lines="1">stokes-1e4-p2p1-TALA-Di-0.25</string_value>
    <comment>This tests compressible stokes. It is a TALA case at a dissipation number of 0.25 and a Rayleigh number of 1e4. Values are compared to the benchmark solutions of King et al. 2009.</comment>
  </simulation_name>
  <problem_type>
    <string_value lines="1">stokes</string_value>
  </problem_type>
  <geometry>
    <dimension>
      <integer_value rank="0">2</integer_value>
    </dimension>
    <mesh name="CoordinateMesh">
      <from_file file_name="square-structured-linear">
        <format name="triangle"/>
        <stat>
          <include_in_stat/>
        </stat>
      </from_file>
    </mesh>
    <mesh name="VelocityMesh">
      <from_mesh>
        <mesh name="CoordinateMesh"/>
        <mesh_shape>
          <polynomial_degree>
            <integer_value rank="0">2</integer_value>
          </polynomial_degree>
        </mesh_shape>
        <stat>
          <exclude_from_stat/>
        </stat>
      </from_mesh>
    </mesh>
    <mesh name="P2DGMesh">
      <from_mesh>
        <mesh name="CoordinateMesh"/>
        <mesh_shape>
          <polynomial_degree>
            <integer_value rank="0">2</integer_value>
          </polynomial_degree>
        </mesh_shape>
        <mesh_continuity>
          <string_value>discontinuous</string_value>
        </mesh_continuity>
        <stat>
          <exclude_from_stat/>
        </stat>
      </from_mesh>
    </mesh>
    <mesh name="P4Mesh">
      <from_mesh>
        <mesh name="CoordinateMesh"/>
        <mesh_shape>
          <polynomial_degree>
            <integer_value rank="0">4</integer_value>
          </polynomial_degree>
        </mesh_shape>
        <stat>
          <exclude_from_stat/>
        </stat>
      </from_mesh>
    </mesh>
    <quadrature>
      <degree>
        <integer_value rank="0">8</integer_value>
      </degree>
    </quadrature>
  </geometry>
  <io>
    <dump_format>
      <string_value>vtk</string_value>
    </dump_format>
    <dump_period_in_timesteps>
      <constant>
        <integer_value rank="0">1</integer_value>
      </constant>
    </dump_period_in_timesteps>
    <output_mesh name="VelocityMesh"/>
    <stat/>
  </io>
  <timestepping>
    <current_time>
      <real_value rank="0">0.0</real_value>
    </current_time>
    <timestep>
      <real_value rank="0">1e4</real_value>
    </timestep>
    <finish_time>
      <real_value rank="0">1e15</real_value>
    </finish_time>
    <final_timestep>
      <integer_value rank="0">50</integer_value>
    </final_timestep>
    <adaptive_timestep>
      <requested_cfl>
        <real_value rank="0">1.0</real_value>
      </requested_cfl>
      <courant_number name="CFLNumber">
        <mesh name="VelocityMesh"/>
      </courant_number>
      <maximum_timestep>
        <real_value rank="0">1.0e7</real_value>
      </maximum_timestep>
      <increase_tolerance>
        <real_value rank="0">2</real_value>
      </increase_tolerance>
    </adaptive_timestep>
  </timestepping>
  <physical_parameters>
    <gravity>
      <magnitude>
        <real_value rank="0">10.</real_value>
      </magnitude>
      <vector_field name="GravityDirection" rank="1">
        <prescribed>
          <mesh name="CoordinateMesh"/>
          <value name="WholeMesh">
            <constant>
              <real_value shape="2" dim1="dim" rank="1">0.0 -1.0</real_value>
            </constant>
          </value>
          <output>
            <exclude_from_vtu/>
          </output>
          <stat>
            <exclude_from_stat/>
          </stat>
          <detectors>
            <exclude_from_detectors/>
          </detectors>
        </prescribed>
      </vector_field>
    </gravity>
  </physical_parameters>
  <material_phase name="Fluid">
    <equation_of_state>
      <compressible>
        <mantle_lookup/>
      </compressible>
    </equation_of_state>
    <scalar_field name="Pressure" rank="0">
      <prognostic>
        <mesh name="CoordinateMesh"/>
        <spatial_discretisation>
          <continuous_galerkin/>
          <compressible/>
        </spatial_discretisation>
        <scheme>
          <poisson_pressure_solution>
            <string_value lines="1">never</string_value>
          </poisson_pressure_solution>
          <use_projection_method>
            <full_schur_complement>
              <inner_matrix name="FullMomentumMatrix">
                <solver>
                  <iterative_method name="preonly"/>
                  <preconditioner name="lu"/>
                  <relative_error>
                    <real_value rank="0">1.0e-7</real_value>
                  </relative_error>
                  <max_iterations>
                    <integer_value rank="0">1000</integer_value>
                  </max_iterations>
                  <start_from_zero/>
                  <never_ignore_solver_failures/>
                  <diagnostics>
                    <monitors/>
                  </diagnostics>
                </solver>
              </inner_matrix>
              <preconditioner_matrix name="ScaledPressureMassMatrix"/>
            </full_schur_complement>
          </use_projection_method>
        </scheme>
        <solver>
          <iterative_method name="fgmres"/>
          <preconditioner name="jacobi"/>
          <relative_error>
            <real_value rank="0">1.0e-8</real_value>
          </relative_error>
          <absolute_error>
            <real_value rank="0">8.0e-17</real_value>
          </absolute_error>
          <max_iterations>
            <integer_value rank="0">10000</integer_value>
          </max_iterations>
          <remove_null_space/>
          <never_ignore_solver_failures/>
          <diagnostics>
            <monitors>
              <preconditioned_residual/>
            </monitors>
          </diagnostics>
        </solver>
        <initial_condition name="WholeMesh">
          <constant>
            <real_value rank="0">1.0</real_value>
          </constant>
        </initial_condition>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <exclude_from_detectors/>
        </detectors>
        <steady_state>
          <exclude_from_steady_state/>
        </steady_state>
        <consistent_interpolation/>
      </prognostic>
    </scalar_field>
    <scalar_field name="Density" rank="0">
      <prognostic>
        <mesh name="VelocityMesh"/>
        <spatial_discretisation>
          <continuous_galerkin>
            <stabilisation>
              <no_stabilisation/>
            </stabilisation>
            <advection_terms/>
            <mass_terms>
              <exclude_mass_terms/>
            </mass_terms>
          </continuous_galerkin>
          <conservative_advection>
            <real_value rank="0">1.0</real_value>
          </conservative_advection>
          <use_reference_density/>
        </spatial_discretisation>
        <temporal_discretisation>
          <theta>
            <real_value rank="0">1.0</real_value>
          </theta>
        </temporal_discretisation>
        <initial_condition name="WholeMesh">
          <python>
            <string_value lines="20" type="code" language="python">def val(X,t):

  import math
  
  rho_zero = 1.0
  gamma = 1.0
  Di = 0.25
  depth = 1.0 - X[1]
  exp_val = (depth*Di)/gamma
  rho_ref = rho_zero * math.exp(exp_val)
  return rho_ref</string_value>
          </python>
        </initial_condition>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
        <consistent_interpolation/>
      </prognostic>
    </scalar_field>
    <vector_field name="Velocity" rank="1">
      <prognostic>
        <mesh name="VelocityMesh"/>
        <equation name="LinearMomentum"/>
        <spatial_discretisation>
          <continuous_galerkin>
            <stabilisation>
              <no_stabilisation/>
            </stabilisation>
            <mass_terms>
              <exclude_mass_terms/>
            </mass_terms>
            <advection_terms>
              <exclude_advection_terms/>
            </advection_terms>
            <stress_terms>
              <partial_stress_form/>
            </stress_terms>
          </continuous_galerkin>
          <conservative_advection>
            <real_value rank="0">1.0</real_value>
          </conservative_advection>
        </spatial_discretisation>
        <temporal_discretisation>
          <theta>
            <real_value rank="0">1</real_value>
          </theta>
          <relaxation>
            <real_value rank="0">1</real_value>
          </relaxation>
        </temporal_discretisation>
        <solver>
          <iterative_method name="preonly"/>
          <preconditioner name="lu"/>
          <relative_error>
            <real_value rank="0">1.0e-7</real_value>
          </relative_error>
          <max_iterations>
            <integer_value rank="0">1000</integer_value>
          </max_iterations>
          <never_ignore_solver_failures/>
          <diagnostics>
            <monitors/>
          </diagnostics>
        </solver>
        <initial_condition name="WholeMesh">
          <constant>
            <real_value shape="2" dim1="dim" rank="1">0.0 0.0</real_value>
          </constant>
        </initial_condition>
        <boundary_conditions name="FreeSlipX">
          <surface_ids>
            <integer_value shape="2" rank="1">1 2</integer_value>
          </surface_ids>
          <type name="dirichlet">
            <align_bc_with_cartesian>
              <x_component>
                <constant>
                  <real_value rank="0">0.0</real_value>
                </constant>
              </x_component>
            </align_bc_with_cartesian>
          </type>
        </boundary_conditions>
        <boundary_conditions name="FreeSlipY">
          <surface_ids>
            <integer_value shape="2" rank="1">3 4</integer_value>
          </surface_ids>
          <type name="dirichlet">
            <align_bc_with_cartesian>
              <y_component>
                <constant>
                  <real_value rank="0">0.0</real_value>
                </constant>
              </y_component>
            </align_bc_with_cartesian>
          </type>
        </boundary_conditions>
        <tensor_field name="Viscosity" rank="2">
          <prescribed>
            <value name="WholeMesh">
              <anisotropic_symmetric>
                <constant>
                  <real_value symmetric="true" dim2="dim" shape="2 2" dim1="dim" rank="2">1.0e22 1.0e22 1.0e22 1.0e22</real_value>
                </constant>
              </anisotropic_symmetric>
            </value>
            <output/>
          </prescribed>
        </tensor_field>
        <output/>
        <stat>
          <include_in_stat/>
          <previous_time_step>
            <exclude_from_stat/>
          </previous_time_step>
          <nonlinear_field>
            <exclude_from_stat/>
          </nonlinear_field>
        </stat>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
        <consistent_interpolation/>
      </prognostic>
    </vector_field>
    <scalar_field name="Temperature" rank="0">
      <prognostic>
        <mesh name="VelocityMesh"/>
        <equation name="MantleAnelasticEnergy"/>
        <spatial_discretisation>
          <continuous_galerkin>
            <stabilisation>
              <no_stabilisation/>
            </stabilisation>
            <advection_terms/>
            <mass_terms/>
          </continuous_galerkin>
          <conservative_advection>
            <real_value rank="0">0.0</real_value>
          </conservative_advection>
        </spatial_discretisation>
        <temporal_discretisation>
          <theta>
            <real_value rank="0">1.0</real_value>
          </theta>
        </temporal_discretisation>
        <solver>
          <iterative_method name="preonly"/>
          <preconditioner name="lu"/>
          <relative_error>
            <real_value rank="0">1.0e-10</real_value>
          </relative_error>
          <max_iterations>
            <integer_value rank="0">10000</integer_value>
          </max_iterations>
          <never_ignore_solver_failures/>
          <diagnostics>
            <monitors>
              <preconditioned_residual/>
            </monitors>
          </diagnostics>
        </solver>
        <initial_condition name="WholeMesh">
          <python>
            <string_value lines="20" type="code" language="python">def val(X,t):
  depth = 2000e3 - X[1]
  T = ((depth/2000e3)*2000. + 300.) + X[0]*0.0002
  if (T &gt; 2300.):
    T = 2300.
  return T</string_value>
          </python>
        </initial_condition>
        <boundary_conditions name="HotBase">
          <surface_ids>
            <integer_value shape="1" rank="1">4</integer_value>
          </surface_ids>
          <type name="dirichlet">
            <constant>
              <real_value rank="0">2300.</real_value>
            </constant>
          </type>
        </boundary_conditions>
        <boundary_conditions name="ColdTop">
          <surface_ids>
            <integer_value shape="1" rank="1">3</integer_value>
          </surface_ids>
          <type name="dirichlet">
            <constant>
              <real_value rank="0">300.</real_value>
            </constant>
          </type>
        </boundary_conditions>
        <boundary_conditions name="Insulating">
          <surface_ids>
            <integer_value shape="2" rank="1">1 2</integer_value>
          </surface_ids>
          <type name="neumann">
            <constant>
              <real_value rank="0">0.0</real_value>
            </constant>
          </type>
        </boundary_conditions>
        <tensor_field name="Diffusivity" rank="2">
          <prescribed>
            <value name="WholeMesh">
              <isotropic>
                <constant>
                  <real_value rank="0">3.3</real_value>
                </constant>
              </isotropic>
            </value>
            <output/>
          </prescribed>
        </tensor_field>
        <scalar_field name="Source" rank="0">
          <diagnostic>
            <mesh name="P2DGMesh"/>
            <algorithm name="viscous_dissipation" material_phase_support="single "/>
            <output/>
            <stat/>
            <detectors>
              <include_in_detectors/>
            </detectors>
          </diagnostic>
        </scalar_field>
        <scalar_field name="Absorption" rank="0">
          <diagnostic>
            <mesh name="VelocityMesh"/>
            <algorithm name="adiabatic_heating_coefficient" material_phase_support="single "/>
            <output/>
            <stat/>
            <detectors>
              <include_in_detectors/>
            </detectors>
          </diagnostic>
        </scalar_field>
        <output/>
        <stat>
          <surface_integral type="gradient_normal" name="LeftH">
            <surface_ids>
              <integer_value shape="1" rank="1">1</integer_value>
            </surface_ids>
          </surface_integral>
          <surface_integral type="gradient_normal" name="RightH">
            <surface_ids>
              <integer_value shape="1" rank="1">2</integer_value>
            </surface_ids>
          </surface_integral>
          <surface_integral type="gradient_normal" name="TopH">
            <surface_ids>
              <integer_value shape="1" rank="1">3</integer_value>
            </surface_ids>
          </surface_integral>
          <surface_integral type="gradient_normal" name="BottomH">
            <surface_ids>
              <integer_value shape="1" rank="1">4</integer_value>
            </surface_ids>
          </surface_integral>
        </stat>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
        <consistent_interpolation/>
      </prognostic>
    </scalar_field>
    <scalar_field name="CompressibleReferenceDensity" rank="0">
      <diagnostic>
        <algorithm name="scalar_python_diagnostic" material_phase_support="single">
          <string_value lines="20" type="code" language="python">import numpy

# Column of attribute required from lookup table:
att_column = 3

def find_nearest(array,value):
    idx=array.searchsorted(value)
    return idx-1
    
# Load Lookup Table. The first time this routine is called, the lookup table is loaded into persistent. On subsequent calls, the data is simply retrieved from persistent. This prevent excessive use of I/O:

if not "LookupReferenceTable" in persistent:
  data = numpy.load("Lookup_Reference.npy")
  persistent["LookupReferenceTable"] = data
else:
  data = persistent["LookupReferenceTable"]

# Load coordinate field from state:
X = state.vector_fields["DiagnosticCoordinate"]
assert(X.node_count == field.node_count)

# Find point in lookup table that is shallower than nodal depth:
for node in range(field.node_count):
  nodal_coordinates = X.node_val(node)
  depth = 2000e3 - nodal_coordinates[1]
  nearest_index=find_nearest(data[:,0],depth)
  # Now interpolate data from surrounding depth points:
  # First normalize distances:
  depth_range = data[nearest_index+1,0] - data[nearest_index,0]
  d1 = 1. - (depth - data[nearest_index,0]) / depth_range
  d2 = 1. - (data[nearest_index+1,0] - depth) / depth_range
  assert(d1 &gt;= 0. and d1 &lt;= 1.)
  assert(d2 &gt;= 0. and d2 &lt;= 1.)
  dens = (d1*data[nearest_index,att_column]+d2*data[nearest_index+1,att_column])
  field.set(node,dens)</string_value>
        </algorithm>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="IsobaricThermalExpansivity" rank="0">
      <diagnostic>
        <algorithm name="scalar_python_diagnostic" material_phase_support="single">
          <string_value lines="20" type="code" language="python">import numpy
import math

# Load Lookup Table. The first time this routine is called, the lookup table is loaded into persistent. On subsequent calls, the data is simply retrieved from persistent. This prevent excessive use of I/O:

if not "LookupTable" in persistent:
  data = numpy.load("Grid_Data.npy")
  persistent["LookupTable"] = data
else:
  data = persistent["LookupTable"]

# Load temperature and pressure fields from state:
T = state.scalar_fields["Temperature"]
assert(T.node_count == field.node_count)
P = state.scalar_fields["Reference_Pressure"]
assert(P.node_count == field.node_count)

# Specify temperature and pressure info for lookup table:
# First specify column of desired property in lookup table:
att_column = 2
# Then temperature info:
tmin = 300.
tmax = 2800.
tinc = 100.
Lookup_Ts = numpy.arange(tmin,tmax+tinc,tinc)
# And pressure info:
pmin = 0.
pmax = 1.4e11
pinc = 1.0e9
Lookup_Ps = numpy.arange(pmin,pmax+pinc,pinc)
# Find point in lookup table that is below nodal T and P value:
for node in range(field.node_count):
  iT = int(numpy.floor((T.node_val(node)-Lookup_Ts[0]) / tinc))
  iP = int(numpy.floor((P.node_val(node)-Lookup_Ps[0]) / pinc)) 
#  print 'TTEST = ',T.node_val(node)
#  print 'IT    = ',iT
#  print 'LENGH = ',len(Lookup_Ts)
  # Now interpolate data from surrounding (T,P) space to get value at the current node:
  # First normalize values. Begin with pressure:
  norm_pres = 1. - ((P.node_val(node) - Lookup_Ps[iP]) / pinc)
  assert(norm_pres &gt;= 0. and norm_pres &lt;= 1.)
  # Next normalise temperature:
  norm_temp = 1. - ((T.node_val(node) - Lookup_Ts[iT]) / tinc)
#  print 'T VAL     = ', T.node_val(node)
#  print 'Lookup Ts = ', Lookup_Ts[iT]
#  print 'TINC      = ', tinc
#  print 'NORM_TEMP = ', norm_temp
  assert(norm_temp &gt;= 0. and norm_temp &lt;= 1.)
  # Calculate contributions from each vertex:
  v1n= norm_temp     *norm_pres     *data[iT  ,iP  ,att_column]
  v2n= (1.-norm_temp)*norm_pres     *data[iT+1,iP  ,att_column]
  v3n= (1.-norm_temp)*(1.-norm_pres)*data[iT+1,iP+1,att_column]
  v4n= norm_temp     *(1.-norm_pres)*data[iT  ,iP+1,att_column]
  # Sum all contributions to get final cp at this node:
  alpha = v1n+v2n+v3n+v4n
  field.set(node,alpha)</string_value>
        </algorithm>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="CompressibleEOSDensity" rank="0">
      <diagnostic>
        <algorithm name="Internal" material_phase_support="multiple"/>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="CompressibleReferenceTemperature" rank="0">
      <diagnostic>
        <algorithm name="scalar_python_diagnostic" material_phase_support="single">
          <string_value lines="20" type="code" language="python">import numpy

# Column of attribute required from lookup table:
att_column = 2

def find_nearest(array,value):
    idx=array.searchsorted(value)
    return idx-1
    
# Load Lookup Table. The first time this routine is called, the lookup table is loaded into persistent. On subsequent calls, the data is simply retrieved from persistent. This prevent excessive use of I/O:

if not "LookupReferenceTable" in persistent:
  data = numpy.load("Lookup_Reference.npy")
  persistent["LookupReferenceTable"] = data
else:
  data = persistent["LookupReferenceTable"]

# Load coordinate field from state:
X = state.vector_fields["DiagnosticCoordinate"]
assert(X.node_count == field.node_count)

# Find point in lookup table that is shallower than nodal depth:
for node in range(field.node_count):
  nodal_coordinates = X.node_val(node)
  depth = 2000e3 - nodal_coordinates[1]
  nearest_index=find_nearest(data[:,0],depth)
  # Now interpolate data from surrounding depth points:
  # First normalize distances:
  depth_range = data[nearest_index+1,0] - data[nearest_index,0]
  d1 = 1. - (depth - data[nearest_index,0]) / depth_range
  d2 = 1. - (data[nearest_index+1,0] - depth) / depth_range
  assert(d1 &gt;= 0. and d1 &lt;= 1.)
  assert(d2 &gt;= 0. and d2 &lt;= 1.)
  rtemp = (d1*data[nearest_index,att_column]+d2*data[nearest_index+1,att_column])
  field.set(node,rtemp)</string_value>
        </algorithm>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="IsobaricSpecificHeatCapacity" rank="0">
      <diagnostic>
        <algorithm name="scalar_python_diagnostic" material_phase_support="single">
          <string_value lines="20" type="code" language="python">import numpy
import math

# Load Lookup Table. The first time this routine is called, the lookup table is loaded into persistent. On subsequent calls, the data is simply retrieved from persistent. This prevent excessive use of I/O:

if not "LookupTable" in persistent:
  data = numpy.load("Grid_Data.npy")
  persistent["LookupTable"] = data
else:
  data = persistent["LookupTable"]

# Load temperature and pressure fields from state:
T = state.scalar_fields["Temperature"]
assert(T.node_count == field.node_count)
P = state.scalar_fields["Reference_Pressure"]
assert(P.node_count == field.node_count)

# Specify temperature and pressure info for lookup table:
# First specify column of desired property in lookup table:
att_column = 1
# Then temperature info:
tmin = 300.
tmax = 2800.
tinc = 100.
Lookup_Ts = numpy.arange(tmin,tmax+tinc,tinc)
# And pressure info:
pmin = 0.
pmax = 1.4e11
pinc = 1.0e9
Lookup_Ps = numpy.arange(pmin,pmax+pinc,pinc)
# Find point in lookup table that is below nodal T and P value:
for node in range(field.node_count):
  iT = int(numpy.floor((T.node_val(node)-Lookup_Ts[0]) / tinc))
  iP = int(numpy.floor((P.node_val(node)-Lookup_Ps[0]) / pinc)) 
#  print 'TTEST = ',T.node_val(node)
#  print 'iT    = ',iT
  # Now interpolate data from surrounding (T,P) space to get value at the current node:
  # First normalize values. Begin with pressure:
  norm_pres = 1. - ((P.node_val(node) - Lookup_Ps[iP]) / pinc)
  assert(norm_pres &gt;= 0. and norm_pres &lt;= 1.)
  # Next normalise temperature:
  norm_temp = 1. - ((T.node_val(node) - Lookup_Ts[iT]) / tinc)
  assert(norm_temp &gt;= 0. and norm_temp &lt;= 1.)
  # Calculate contributions from each vertex:
  v1n= norm_temp     *norm_pres     *data[iT  ,iP  ,att_column]
  v2n= (1.-norm_temp)*norm_pres     *data[iT+1,iP  ,att_column]
  v3n= (1.-norm_temp)*(1.-norm_pres)*data[iT+1,iP+1,att_column]
  v4n= norm_temp     *(1.-norm_pres)*data[iT  ,iP+1,att_column]
  # Sum all contributions to get final cp at this node:
  cp = v1n+v2n+v3n+v4n
  field.set(node,cp)</string_value>
        </algorithm>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="Reference_Pressure" rank="0">
      <diagnostic>
        <algorithm name="scalar_python_diagnostic" material_phase_support="single">
          <string_value lines="20" type="code" language="python">import numpy

# Column of attribute required from lookup table:
att_column = 1

def find_nearest(array,value):
    idx=array.searchsorted(value)
    return idx-1
    
# Load Lookup Table. The first time this routine is called, the lookup table is loaded into persistent. On subsequent calls, the data is simply retrieved from persistent. This prevent excessive use of I/O:

if not "LookupReferenceTable" in persistent:
  data = numpy.load("Lookup_Reference.npy")
  persistent["LookupReferenceTable"] = data
else:
  data = persistent["LookupReferenceTable"]

# Load coordinate field from state:
X = state.vector_fields["DiagnosticCoordinate"]
assert(X.node_count == field.node_count)

# Find point in lookup table that is shallower than nodal depth:
for node in range(field.node_count):
  nodal_coordinates = X.node_val(node)
  depth = 2000e3 - nodal_coordinates[1]
  nearest_index=find_nearest(data[:,0],depth)
  # Now interpolate data from surrounding depth points:
  # First normalize distances:
  depth_range = data[nearest_index+1,0] - data[nearest_index,0]
  d1 = 1. - (depth - data[nearest_index,0]) / depth_range
  d2 = 1. - (data[nearest_index+1,0] - depth) / depth_range
  assert(d1 &gt;= 0. and d1 &lt;= 1.)
  assert(d2 &gt;= 0. and d2 &lt;= 1.)
  pres = (d1*data[nearest_index,att_column]+d2*data[nearest_index+1,att_column])
  field.set(node,pres)</string_value>
        </algorithm>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="FullLookupDensity" rank="0">
      <diagnostic>
        <algorithm name="scalar_python_diagnostic" material_phase_support="single">
          <string_value lines="20" type="code" language="python">import numpy
import math

# Load Lookup Table. The first time this routine is called, the lookup table is loaded into persistent. On subsequent calls, the data is simply retrieved from persistent. This prevent excessive use of I/O:

if not "LookupTable" in persistent:
  data = numpy.load("Grid_Data.npy")
  persistent["LookupTable"] = data
else:
  data = persistent["LookupTable"]

# Load temperature and pressure fields from state:
T = state.scalar_fields["Temperature"]
assert(T.node_count == field.node_count)
P = state.scalar_fields["Reference_Pressure"]
assert(P.node_count == field.node_count)

# Specify temperature and pressure info for lookup table:
# First specify column of desired property in lookup table:
att_column = 0
# Then temperature info:
tmin = 300.
tmax = 2800.
tinc = 100.
Lookup_Ts = numpy.arange(tmin,tmax+tinc,tinc)
# And pressure info:
pmin = 0.
pmax = 1.4e11
pinc = 1.0e9
Lookup_Ps = numpy.arange(pmin,pmax+pinc,pinc)
# Find point in lookup table that is below nodal T and P value:
for node in range(field.node_count):
  iT = int(numpy.floor((T.node_val(node)-Lookup_Ts[0]) / tinc))
  iP = int(numpy.floor((P.node_val(node)-Lookup_Ps[0]) / pinc)) 
  # Now interpolate data from surrounding (T,P) space to get value at the current node:
  # First normalize values. Begin with pressure:
  norm_pres = 1. - ((P.node_val(node) - Lookup_Ps[iP]) / pinc)
  assert(norm_pres &gt;= 0. and norm_pres &lt;= 1.)
  # Next normalise temperature:
  norm_temp = 1. - ((T.node_val(node) - Lookup_Ts[iT]) / tinc)
  assert(norm_temp &gt;= 0. and norm_temp &lt;= 1.)
  # Calculate contributions from each vertex:
  v1n= norm_temp     *norm_pres     *data[iT  ,iP  ,att_column]
  v2n= (1.-norm_temp)*norm_pres     *data[iT+1,iP  ,att_column]
  v3n= (1.-norm_temp)*(1.-norm_pres)*data[iT+1,iP+1,att_column]
  v4n= norm_temp     *(1.-norm_pres)*data[iT  ,iP+1,att_column]
  # Sum all contributions to get final cp at this node:
  dens = v1n+v2n+v3n+v4n
  field.set(node,dens)</string_value>
        </algorithm>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="CFLNumber" rank="0">
      <diagnostic>
        <algorithm name="Internal" material_phase_support="multiple"/>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="FiniteElementDivergence" rank="0">
      <diagnostic field_name="Velocity">
        <algorithm legacy="true" name="Internal" material_phase_support="multiple"/>
        <mesh name="CoordinateMesh"/>
        <solver>
          <iterative_method name="preonly"/>
          <preconditioner name="lu"/>
          <relative_error>
            <real_value rank="0">1.0e-12</real_value>
          </relative_error>
          <max_iterations>
            <integer_value rank="0">10000</integer_value>
          </max_iterations>
          <never_ignore_solver_failures/>
          <diagnostics>
            <monitors/>
          </diagnostics>
        </solver>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <vector_field name="DiagnosticCoordinate" rank="1">
      <diagnostic>
        <algorithm name="Internal" material_phase_support="multiple"/>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat>
          <include_in_stat/>
        </stat>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </vector_field>
  </material_phase>
</fluidity_options>
