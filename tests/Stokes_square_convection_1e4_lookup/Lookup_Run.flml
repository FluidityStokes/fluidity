<?xml version='1.0' encoding='utf-8'?>
<fluidity_options>
  <simulation_name>
    <string_value lines="1">Mantle_Lookup_Test</string_value>
  </simulation_name>
  <problem_type>
    <string_value lines="1">stokes</string_value>
  </problem_type>
  <geometry>
    <dimension>
      <integer_value rank="0">2</integer_value>
    </dimension>
    <mesh name="CoordinateMesh">
      <from_file file_name="src/Lookup_Mesh">
        <format name="gmsh"/>
        <stat>
          <include_in_stat/>
        </stat>
      </from_file>
    </mesh>
    <mesh name="VelocityMesh">
      <from_mesh>
        <mesh name="CoordinateMesh"/>
        <mesh_shape>
          <polynomial_degree>
            <integer_value rank="0">2</integer_value>
          </polynomial_degree>
        </mesh_shape>
        <stat>
          <exclude_from_stat/>
        </stat>
      </from_mesh>
    </mesh>
    <mesh name="P2DGMesh">
      <from_mesh>
        <mesh name="CoordinateMesh"/>
        <mesh_shape>
          <polynomial_degree>
            <integer_value rank="0">2</integer_value>
          </polynomial_degree>
        </mesh_shape>
        <mesh_continuity>
          <string_value>discontinuous</string_value>
        </mesh_continuity>
        <stat>
          <exclude_from_stat/>
        </stat>
      </from_mesh>
    </mesh>
    <quadrature>
      <degree>
        <integer_value rank="0">5</integer_value>
      </degree>
    </quadrature>
  </geometry>
  <io>
    <dump_format>
      <string_value>vtk</string_value>
    </dump_format>
    <dump_period_in_timesteps>
      <constant>
        <integer_value rank="0">20</integer_value>
      </constant>
    </dump_period_in_timesteps>
    <output_mesh name="CoordinateMesh"/>
    <checkpointing>
      <checkpoint_period_in_dumps>
        <integer_value rank="0">10</integer_value>
      </checkpoint_period_in_dumps>
      <checkpoint_at_end/>
    </checkpointing>
    <stat/>
  </io>
  <timestepping>
    <current_time>
      <real_value rank="0">0.0</real_value>
    </current_time>
    <timestep>
      <real_value rank="0">1e5</real_value>
    </timestep>
    <finish_time>
      <real_value rank="0">1.0e20</real_value>
    </finish_time>
    <final_timestep>
      <integer_value rank="0">1</integer_value>
    </final_timestep>
    <adaptive_timestep>
      <requested_cfl>
        <real_value rank="0">0.5</real_value>
      </requested_cfl>
      <courant_number name="CFLNumber">
        <mesh name="CoordinateMesh"/>
      </courant_number>
      <increase_tolerance>
        <real_value rank="0">2.5</real_value>
      </increase_tolerance>
    </adaptive_timestep>
  </timestepping>
  <physical_parameters>
    <gravity>
      <magnitude>
        <real_value rank="0">10.0</real_value>
      </magnitude>
      <vector_field name="GravityDirection" rank="1">
        <prescribed>
          <mesh name="CoordinateMesh"/>
          <value name="WholeMesh">
            <constant>
              <real_value shape="2" dim1="dim" rank="1">0.0 -1.0</real_value>
            </constant>
          </value>
          <output>
            <exclude_from_vtu/>
          </output>
          <stat>
            <exclude_from_stat/>
          </stat>
          <detectors>
            <exclude_from_detectors/>
          </detectors>
        </prescribed>
      </vector_field>
    </gravity>
  </physical_parameters>
  <material_phase name="Mantle">
    <equation_of_state>
      <compressible>
        <mantle_lookup/>
      </compressible>
    </equation_of_state>
    <scalar_field name="Pressure" rank="0">
      <prognostic>
        <mesh name="CoordinateMesh"/>
        <spatial_discretisation>
          <continuous_galerkin>
            <remove_stabilisation_term/>
          </continuous_galerkin>
          <compressible/>
        </spatial_discretisation>
        <scheme>
          <poisson_pressure_solution>
            <string_value lines="1">never</string_value>
          </poisson_pressure_solution>
          <use_projection_method>
            <full_schur_complement>
              <inner_matrix name="FullMomentumMatrix">
                <solver>
                  <iterative_method name="preonly"/>
                  <preconditioner name="lu"/>
                  <relative_error>
                    <real_value rank="0">1.0e-7</real_value>
                  </relative_error>
                  <max_iterations>
                    <integer_value rank="0">1000</integer_value>
                  </max_iterations>
                  <start_from_zero/>
                  <never_ignore_solver_failures/>
                  <diagnostics>
                    <monitors/>
                  </diagnostics>
                </solver>
              </inner_matrix>
              <preconditioner_matrix name="DiagonalSchurComplement"/>
            </full_schur_complement>
          </use_projection_method>
        </scheme>
        <solver>
          <iterative_method name="fgmres"/>
          <preconditioner name="jacobi"/>
          <relative_error>
            <real_value rank="0">1.0e-4</real_value>
          </relative_error>
          <absolute_error>
            <real_value rank="0">5.0e-16</real_value>
          </absolute_error>
          <max_iterations>
            <integer_value rank="0">1000</integer_value>
          </max_iterations>
          <remove_null_space/>
          <never_ignore_solver_failures/>
          <diagnostics>
            <monitors>
              <preconditioned_residual/>
            </monitors>
          </diagnostics>
        </solver>
        <initial_condition name="WholeMesh">
          <constant>
            <real_value rank="0">1.0</real_value>
          </constant>
        </initial_condition>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <exclude_from_detectors/>
        </detectors>
        <steady_state>
          <exclude_from_steady_state/>
        </steady_state>
        <no_interpolation/>
      </prognostic>
    </scalar_field>
    <scalar_field name="Density" rank="0">
      <prognostic>
        <mesh name="VelocityMesh"/>
        <spatial_discretisation>
          <continuous_galerkin>
            <stabilisation>
              <no_stabilisation/>
            </stabilisation>
            <advection_terms/>
            <mass_terms>
              <exclude_mass_terms/>
            </mass_terms>
          </continuous_galerkin>
          <conservative_advection>
            <real_value rank="0">1.0</real_value>
          </conservative_advection>
          <use_reference_density/>
        </spatial_discretisation>
        <temporal_discretisation>
          <theta>
            <real_value rank="0">1.0</real_value>
          </theta>
        </temporal_discretisation>
        <initial_condition name="WholeMesh">
          <constant>
            <real_value rank="0">1.0</real_value>
          </constant>
        </initial_condition>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <exclude_from_steady_state/>
        </steady_state>
        <consistent_interpolation/>
      </prognostic>
    </scalar_field>
    <vector_field name="Velocity" rank="1">
      <prognostic>
        <mesh name="VelocityMesh"/>
        <equation name="LinearMomentum"/>
        <spatial_discretisation>
          <continuous_galerkin>
            <stabilisation>
              <no_stabilisation/>
            </stabilisation>
            <mass_terms>
              <exclude_mass_terms/>
            </mass_terms>
            <advection_terms>
              <exclude_advection_terms/>
            </advection_terms>
            <stress_terms>
              <tensor_form/>
            </stress_terms>
          </continuous_galerkin>
          <conservative_advection>
            <real_value rank="0">1.0</real_value>
          </conservative_advection>
        </spatial_discretisation>
        <temporal_discretisation>
          <theta>
            <real_value rank="0">1.0</real_value>
          </theta>
          <relaxation>
            <real_value rank="0">1.0</real_value>
          </relaxation>
        </temporal_discretisation>
        <solver>
          <iterative_method name="preonly"/>
          <preconditioner name="lu"/>
          <relative_error>
            <real_value rank="0">1.0e-7</real_value>
          </relative_error>
          <max_iterations>
            <integer_value rank="0">1000</integer_value>
          </max_iterations>
          <never_ignore_solver_failures/>
          <diagnostics>
            <monitors/>
          </diagnostics>
        </solver>
        <initial_condition name="WholeMesh">
          <constant>
            <real_value shape="2" dim1="dim" rank="1">0.0 0.0</real_value>
          </constant>
        </initial_condition>
        <boundary_conditions name="FreeSlipX">
          <surface_ids>
            <integer_value shape="2" rank="1">6 8</integer_value>
          </surface_ids>
          <type name="dirichlet">
            <align_bc_with_cartesian>
              <x_component>
                <constant>
                  <real_value rank="0">0.0</real_value>
                </constant>
              </x_component>
            </align_bc_with_cartesian>
          </type>
        </boundary_conditions>
        <boundary_conditions name="FreeSlipY">
          <surface_ids>
            <integer_value shape="2" rank="1">7 9</integer_value>
          </surface_ids>
          <type name="dirichlet">
            <align_bc_with_cartesian>
              <y_component>
                <constant>
                  <real_value rank="0">0.0</real_value>
                </constant>
              </y_component>
            </align_bc_with_cartesian>
          </type>
        </boundary_conditions>
        <tensor_field name="Viscosity" rank="2">
          <prescribed>
            <value name="WholeMesh">
              <isotropic>
                <constant>
                  <real_value rank="0">1.0e22</real_value>
                </constant>
              </isotropic>
            </value>
            <output/>
          </prescribed>
        </tensor_field>
        <output/>
        <stat>
          <include_in_stat/>
          <previous_time_step>
            <exclude_from_stat/>
          </previous_time_step>
          <nonlinear_field>
            <exclude_from_stat/>
          </nonlinear_field>
        </stat>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <exclude_from_steady_state/>
        </steady_state>
        <consistent_interpolation/>
      </prognostic>
    </vector_field>
    <scalar_field name="Temperature" rank="0">
      <prognostic>
        <mesh name="CoordinateMesh"/>
        <equation name="MantleAnelasticEnergy"/>
        <spatial_discretisation>
          <continuous_galerkin>
            <stabilisation>
              <no_stabilisation/>
            </stabilisation>
            <advection_terms/>
            <mass_terms/>
          </continuous_galerkin>
          <conservative_advection>
            <real_value rank="0">0.5</real_value>
          </conservative_advection>
        </spatial_discretisation>
        <temporal_discretisation>
          <theta>
            <real_value rank="0">0.5</real_value>
          </theta>
        </temporal_discretisation>
        <solver>
          <iterative_method name="preonly"/>
          <preconditioner name="lu"/>
          <relative_error>
            <real_value rank="0">1.0e-7</real_value>
          </relative_error>
          <max_iterations>
            <integer_value rank="0">1000</integer_value>
          </max_iterations>
          <never_ignore_solver_failures/>
          <diagnostics>
            <monitors/>
          </diagnostics>
        </solver>
        <initial_condition name="WholeMesh">
          <python>
            <string_value lines="20" type="code" language="python">def val(X,t):
  tmax = 2032.5838
  tmin = 300.
  depth = X[1]
  T = ((depth/1000e3)*(tmax-tmin)*-1. + tmin) + X[0]*0.0003
  if (T &gt; tmax):
    T = tmax
  if (T &lt; tmin):
    T = tmin
  return T</string_value>
          </python>
        </initial_condition>
        <boundary_conditions name="HotBase">
          <surface_ids>
            <integer_value shape="1" rank="1">7</integer_value>
          </surface_ids>
          <type name="dirichlet">
            <constant>
              <real_value rank="0">2032.5838</real_value>
            </constant>
          </type>
        </boundary_conditions>
        <boundary_conditions name="ColdTop">
          <surface_ids>
            <integer_value shape="1" rank="1">9</integer_value>
          </surface_ids>
          <type name="dirichlet">
            <constant>
              <real_value rank="0">300.</real_value>
            </constant>
          </type>
        </boundary_conditions>
        <boundary_conditions name="Insulating">
          <surface_ids>
            <integer_value shape="2" rank="1">6 8</integer_value>
          </surface_ids>
          <type name="neumann">
            <constant>
              <real_value rank="0">0.0</real_value>
            </constant>
          </type>
        </boundary_conditions>
        <tensor_field name="Diffusivity" rank="2">
          <prescribed>
            <value name="WholeMesh">
              <isotropic>
                <constant>
                  <real_value rank="0">4.0</real_value>
                </constant>
              </isotropic>
            </value>
            <output/>
          </prescribed>
        </tensor_field>
        <scalar_field name="Source" rank="0">
          <diagnostic>
            <mesh name="P2DGMesh"/>
            <algorithm name="viscous_dissipation" material_phase_support="single "/>
            <output>
              <exclude_from_vtu/>
            </output>
            <stat/>
            <detectors>
              <include_in_detectors/>
            </detectors>
          </diagnostic>
        </scalar_field>
        <scalar_field name="Absorption" rank="0">
          <diagnostic>
            <mesh name="VelocityMesh"/>
            <algorithm name="adiabatic_heating_coefficient" material_phase_support="single "/>
            <output/>
            <stat/>
            <detectors>
              <include_in_detectors/>
            </detectors>
          </diagnostic>
        </scalar_field>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
        <consistent_interpolation/>
      </prognostic>
    </scalar_field>
    <scalar_field name="CompressibleReferenceDensity" rank="0">
      <diagnostic>
        <algorithm name="scalar_python_diagnostic" material_phase_support="single">
          <string_value lines="20" type="code" language="python">from lookup_functions import *
 
# Load Lookup Table. The first time this routine is called, the lookup table is loaded into persistent. On subsequent calls, the data is simply retrieved from persistent. This prevent excessive use of I/O:

if not "LookupReferenceTable" in persistent:
  data = numpy.load("grid_data/Lookup_Reference.npy")
  persistent["LookupReferenceTable"] = data
else:
  data = persistent["LookupReferenceTable"]

# Load coordinate field from state:
X = state.vector_fields["DiagnosticCoordinate"]
assert(X.node_count == field.node_count)

# Find point in lookup table that is shallower than nodal depth:
for node in range(field.node_count):
  reference_value = get_reference_property(data,X.node_val(node),field.name)
  field.set(node,reference_value*1000.)</string_value>
        </algorithm>
        <mesh name="CoordinateMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="IsobaricThermalExpansivity" rank="0">
      <diagnostic>
        <algorithm name="scalar_python_diagnostic" material_phase_support="single">
          <string_value lines="20" type="code" language="python">from lookup_functions import *

# Load Lookup Table. The first time this routine is called, the lookup table is loaded into persistent, as "LookupTable". On subsequent calls, the data is simply retrieved from persistent. This prevent excessive use of I/O, which will become more and more important as the lookup tables increase in size:

if not "LookupTable" in persistent:
  data = numpy.load("grid_data/Grid_Data.npy")
  persistent["LookupTable"] = data
else:
  data = persistent["LookupTable"]

# Load temperature and pressure fields from state:
T = state.scalar_fields["Full_Temperature"]
assert(T.node_count == field.node_count)
P = state.scalar_fields["Reference_Pressure"]
assert(P.node_count == field.node_count)

for node in range(field.node_count):
  effective_alpha = calculate_effective_alpha(data, T.node_val(node),P.node_val(node))
  field.set(node,effective_alpha)</string_value>
          <depends>
            <string_value lines="1">Full_Temperature, Reference_Pressure</string_value>
          </depends>
        </algorithm>
        <mesh name="CoordinateMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="CompressibleEOSDensity" rank="0">
      <diagnostic>
        <algorithm name="Internal" material_phase_support="multiple"/>
        <mesh name="CoordinateMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="CompressibleReferenceTemperature" rank="0">
      <diagnostic>
        <algorithm name="scalar_python_diagnostic" material_phase_support="single">
          <string_value lines="20" type="code" language="python">from lookup_functions import *
 
# Load Lookup Table. The first time this routine is called, the lookup table is loaded into persistent. On subsequent calls, the data is simply retrieved from persistent. This prevent excessive use of I/O:

if not "LookupReferenceTable" in persistent:
  data = numpy.load("grid_data/Lookup_Reference.npy")
  persistent["LookupReferenceTable"] = data
else:
  data = persistent["LookupReferenceTable"]

# Load coordinate field from state:
X = state.vector_fields["DiagnosticCoordinate"]
assert(X.node_count == field.node_count)

# Find point in lookup table that is shallower than nodal depth:
for node in range(field.node_count):
  reference_value = get_reference_property(data,X.node_val(node),field.name)
  field.set(node,reference_value)</string_value>
        </algorithm>
        <mesh name="CoordinateMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="IsobaricSpecificHeatCapacity" rank="0">
      <diagnostic>
        <algorithm name="scalar_python_diagnostic" material_phase_support="single">
          <string_value lines="20" type="code" language="python">from lookup_functions import *

# Load Lookup Table. The first time this routine is called, the lookup table is loaded into persistent, as "LookupTable". On subsequent calls, the data is simply retrieved from persistent. This prevent excessive use of I/O, which will become more and more important as the lookup tables increase in size:

# Isobaric Specific Heat Capacity
if not "LookupTable" in persistent:
  data = numpy.load("grid_data/Grid_Data.npy")
  persistent["LookupTable"] = data
else:
  data = persistent["LookupTable"]

# Load temperature and pressure fields from state:
T = state.scalar_fields["Full_Temperature"]
assert(T.node_count == field.node_count)
P = state.scalar_fields["Reference_Pressure"]
assert(P.node_count == field.node_count)

for node in range(field.node_count):
  effective_cp = calculate_effective_cp(data, T.node_val(node),P.node_val(node))
  field.set(node,effective_cp)</string_value>
          <depends>
            <string_value lines="1">Full_Temperature, Reference_Pressure</string_value>
          </depends>
        </algorithm>
        <mesh name="CoordinateMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="Reference_Pressure" rank="0">
      <diagnostic>
        <algorithm name="scalar_python_diagnostic" material_phase_support="single">
          <string_value lines="20" type="code" language="python">from lookup_functions import *
 
# Load Lookup Table. The first time this routine is called, the lookup table is loaded into persistent. On subsequent calls, the data is simply retrieved from persistent. This prevent excessive use of I/O:

if not "LookupReferenceTable" in persistent:
  data = numpy.load("grid_data/Lookup_Reference.npy")
  persistent["LookupReferenceTable"] = data
else:
  data = persistent["LookupReferenceTable"]

# Load coordinate field from state:
X = state.vector_fields["DiagnosticCoordinate"]
assert(X.node_count == field.node_count)

# Find point in lookup table that is shallower than nodal depth:
for node in range(field.node_count):
  reference_value = get_reference_property(data,X.node_val(node),field.name)
  field.set(node,reference_value)</string_value>
        </algorithm>
        <mesh name="CoordinateMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="FullLookupDensity" rank="0">
      <diagnostic>
        <algorithm name="scalar_python_diagnostic" material_phase_support="single">
          <string_value lines="20" type="code" language="python">from lookup_functions import *

# Load Lookup Table. The first time this routine is called, the lookup table is loaded into persistent, as "LookupTable". On subsequent calls, the data is simply retrieved from persistent. This prevent excessive use of I/O, which will become more and more important as the lookup tables increase in size:

# Full Lookup Density:

if not "LookupTable" in persistent:
  data = numpy.load("grid_data/Grid_Data.npy")
  persistent["LookupTable"] = data
else:
  data = persistent["LookupTable"]

# Load temperature and pressure fields from state:
T = state.scalar_fields["Full_Temperature"]
assert(T.node_count == field.node_count)
P = state.scalar_fields["Reference_Pressure"]
assert(P.node_count == field.node_count)

for node in range(field.node_count):
  nodal_value = get_material_property(data, T.node_val(node),P.node_val(node),field.name)
  field.set(node,nodal_value*1000.)</string_value>
          <depends>
            <string_value lines="1">Full_Temperature, Reference_Pressure</string_value>
          </depends>
        </algorithm>
        <mesh name="CoordinateMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="Enthalpy" rank="0">
      <diagnostic>
        <algorithm name="scalar_python_diagnostic" material_phase_support="single">
          <string_value lines="20" type="code" language="python">from lookup_functions import *

# Load Lookup Table. The first time this routine is called, the lookup table is loaded into persistent, as "LookupTable". On subsequent calls, the data is simply retrieved from persistent. This prevent excessive use of I/O, which will become more and more important as the lookup tables increase in size:

# Enthalpy:

if not "LookupTable" in persistent:
  data = numpy.load("grid_data/Grid_Data.npy")
  persistent["LookupTable"] = data
else:
  data = persistent["LookupTable"]

# Load temperature and pressure fields from state:
T = state.scalar_fields["Full_Temperature"]
assert(T.node_count == field.node_count)
P = state.scalar_fields["Reference_Pressure"]
assert(P.node_count == field.node_count)

for node in range(field.node_count):
  nodal_value = get_material_property(data, T.node_val(node),P.node_val(node),field.name)
  field.set(node,nodal_value*1000.)</string_value>
          <depends>
            <string_value lines="1">Full_Temperature, Reference_Pressure</string_value>
          </depends>
        </algorithm>
        <mesh name="CoordinateMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="Adiabatic_Heating" rank="0">
      <diagnostic>
        <algorithm name="adiabatic_heating_absorption" material_phase_support="single "/>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="CFLNumber" rank="0">
      <diagnostic>
        <algorithm name="Internal" material_phase_support="multiple"/>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="Full_Temperature" rank="0">
      <diagnostic>
        <algorithm source_field_2_type="scalar" name="scalar_sum" source_field_1_name="Temperature" source_field_2_name="CompressibleReferenceTemperature" material_phase_support="single" source_field_1_type="scalar"/>
        <mesh name="CoordinateMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <vector_field name="DiagnosticCoordinate" rank="1">
      <diagnostic>
        <algorithm name="Internal" material_phase_support="multiple"/>
        <mesh name="CoordinateMesh"/>
        <output/>
        <stat>
          <include_in_stat/>
        </stat>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </vector_field>
    <tensor_field name="Strain_Rate" rank="2">
      <diagnostic>
        <algorithm source_field_type="vector" material_phase_support="single " name="strain_rate" source_field_name="Velocity"/>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat>
          <include_in_stat/>
        </stat>
      </diagnostic>
    </tensor_field>
  </material_phase>
</fluidity_options>
